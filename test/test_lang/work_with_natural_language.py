import stanza
import json
import sqlite3



# unique_set = {
#     "екранний зйомка", "екранний знімок", "екранний зображення", 
#     "екранний копія", "екранний світлина", "екранний скрін", 
#     "екранний скріна", "екранний фото", "екранний фотографія", 
#     "зйомка екран", "знімок", "знімок вікно", "знімок дисплей", 
#     "знімок диспло", "знімок екран", "знімок монітор", 
#     "зображення дисплей", "зображення екран", "зображення монітор", 
#     "картинка екран", "картинка монітор", "скриншот", 
#     "скрін", "скрін екран", "скріна", "скріна екран", 
#     "скріншот", "скріншот вікно", "скріншот екран", 
#     "скріншот монітор", "фото дисплей", "фото диспло", 
#     "фото екран", "фото екранний вміст", "фотографія екран"
# }


# a = "знімок екран"
# if a in unique_set:
#     print("Знайдено!")
# else:
#     print("Не знайдено!")






# scrin = [
#         "екранний зйомка", "екранний знімок", "екранний зображення", 
#         "екранний копія", "екранний світлина", "екранний скрін", 
#         "екранний скріна", "екранний фото", "екранний фотографія", 
#         "зйомка екран", "знімок", "знімок вікно", "знімок дисплей", 
#         "знімок диспло", "знімок екран", "знімок монітор", 
#         "зображення дисплей", "зображення екран", "зображення монітор", 
#         "картинка екран", "картинка монітор", "скриншот", 
#         "скрін", "скрін екран", "скріна", "скріна екран", 
#         "скріншот", "скріншот вікно", "скріншот екран", 
#         "скріншот монітор", "фото дисплей", "фото диспло", 
#         "фото екран", "фото екранний вміст", "фотографія екран"
#     ]


# print(len(scrin))
output_data=[]
with open('synonyms.json', 'r', encoding='utf-8') as f:
    output_data = json.load(f)
    # print(output_data)

a = "скрін"
# print(output_data)

def command_chck():
    for key, value in output_data.items():
        if a in value:
            print("good")
    








# # Завантажуємо модель при умові якщо цього не зроблено
# stanza.download('uk')

# nlp = stanza.Pipeline('uk', processors='tokenize,mwt,pos,lemma', download_method=None) 
# # download_method - забороняє автоматичне завантаження ресурсів під час виконання pipeline, тобто вмикається офлайн-режим
# # mwt - Multi-Word Token Expansion - обробляє багатослівні токени — слова, які складаються з кількох частин
# # pos - Part-of-Speech Tagging - цей процесор визначає частини мови для кожного слова.

# text = "скріншот, знімок екран, екранний копія, скрін, знімок, картинка екран, знімок екран, фото екран, скріншот екран, скриншот, знімок монітор, картинка екран, знімок дисплей, екранний зображення, зображення екран, зображення монітор, екранний зйомка, екранний знімок, знімок екран, знімок екран, фото дисплей, фото екран, картинка монітор, екранний фотографія, скріншот монітор, скрін екран, екранний фото, зображення екран, фото екран, знімок екран, знімок дисплей, знімок вікно, екранний світлина, скріншот вікно, картинка екран, фото екранний вміст, зйомка екран, зображення дисплей, екранний знімок, фотографія екран, скріншот екран, екранний зйомка,екранний скрін, фото екран"


# mytable = str.maketrans(" ", " ", "./,-")
# # перше значення що саме ми хочемо замінити
# # чим саме ми хочемо замінити перше значення
# # що ми хочемо видалити

# clear_text = text.translate(mytable) # очищення слів від ,-/.

# doc = nlp(clear_text) 

# lemmas = [word.lemma for sentence in doc.sentences for word in sentence.words]
# print(lemmas)



# # mytable = str.maketrans(",", "-")
# # print(txt.translate(mytable))

from rapidfuzz import fuzz
print(fuzz.ratio("кіт їх", "кіт їх торт"))

# кіт
# кіт їх
# кіт їх торт
# кіт їх торт і
# кіт їх торт і плаче
# кіт їх торт і плаче
# кіт їх торт і плаче
# кіт їсть торт і плач
